package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/jwowillo/fill/file"
	"github.com/jwowillo/fill/get"
	"github.com/jwowillo/fill/replace"
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		fail(err)
	}
	relative := buildPath(types)
	if err := get.To(pkg, relative); err != nil {
		fail(err)
	}
	to := filepath.Join(relative, filepath.Base(pkg))
	topkg, err := file.Package(filepath.Join(wd, to))
	if err != nil {
		fail(err)
	}
	if err := replace.PackageTypes(topkg, types); err != nil {
		fail(err)
	}
	if err := addREADME(to, pkg); err != nil {
		fail(err)
	}
}

var (
	pkg   string
	types map[string]string
)

func init() {
	var tstring string
	flag.StringVar(&pkg, "package", "", "URL of package to fill")
	flag.StringVar(&tstring, "types", "", "<OLD_TYPE>=<NEW_TYPE>,...")
	flag.Parse()
	if pkg == "" {
		flag.Usage()
		os.Exit(2)
	}
	types = make(map[string]string)
	for _, arg := range strings.Split(tstring, ",") {
		parts := strings.Split(arg, "=")
		if len(parts) != 2 {
			flag.Usage()
			os.Exit(2)
		}
		types[parts[0]] = parts[1]
	}
}

func buildPath(types map[string]string) string {
	ts := make([]string, 0, len(types))
	for _, t := range types {
		ts = append(ts, t)
	}
	sort.Strings(ts)
	return filepath.Join("internal", strings.ToLower(strings.Join(ts, "")))
}

func addREADME(dir, pkg string) error {
	content := "# Generated by `fill`\n\n"
	content += fmt.Sprintf(
		"From https://%s by https://%s.",
		pkg,
		"github.com/jwowillo/fill",
	)
	return file.Write(filepath.Join(dir, "README.md"), []byte(content))
}

func fail(err error) {
	fmt.Fprintln(os.Stderr, err.Error())
	os.Exit(1)
}
